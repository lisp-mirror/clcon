Здесь мы пытаемся разобраться в отладчике SBCL
===============================================

А именно, мы хотим показать исходный текст для функции, вычисляемой в my-eval. 
В чём проблема?

1. Как технически мы найдём исходный текст? 
(SB-INTROSPECT:FIND-DEFINITION-SOURCE функция) показывает исходный текст с точностью до toplevel-формы. 
Внутри progn не показывает. Т.е. так мы можем найти функцию, в к-рой мы находимся, и не со 100% точностью. 

2. Что ждёт нас при попытке найти форму? 

2.1. Определение функции, хранимое для интерпретируемой функции, не совпадает с исходным текстом этой ф-ии. 
Поэтому, даже если мы идентифицировали подформу внутри записанного определения, это нам ничего не даёт для
отображения "настоящего" исходника в файле. В качестве костыля мы можем показать место не в настоящем исходнике, 
а в том, который записан в определении интерпретируемой ф-ии. Как мы это сделаем? 
- определим путь к форме (по образу и подобию SB-INT:LOAD-AS-SOURCE, с помощью переменной
  sb-c::*source-info*) ЛИБО по мотивам компилятора, с помощью sb-c::*source-paths*. Причём, есть ощущение, 
что только второй способ действительно позволит дойти до цели. 
- напечатаем записанное определение во временный файл
- покажем определение (видимо, по мотивам компилятора)


Как компилятор запоминает пути к эл-там исходного текста?
---------------------------------------------------------


compile-file - тут вход в компиляцию 
  sb-c::sub-sub-compile-file
    (do-forms-from-info ((form current-index) info
                         'input-error-in-compile-file)
      (sb-c::with-source-paths
        (sb-c::find-source-paths form current-index)
        ; вот здесь мы имеем доступ к информации о путях
          (sb-c::process-toplevel-form ...)
            (let *current-path* path - в *current-path* содержится путь к текущей подформе. 

Система координат для идентификации формы - это номер свободной формы в файле и _НОМЕР_ подформы внутри свободной формы. 

Однако пути устроены по-другому - это путь из car-ов и cdr-oв. 

Структура sb-c::code-location содержит с-му координат для идентификации и используется swank-ом для поиска определения. 

Так что наша задача - создать sb-c::code-location из путей. Компилятор для этой цели пользуется

SB-C::MAKE-DEFINITION-SOURCE-LOCATION - читает *source-info* и *current-path*, но создаёт ДРУГОЙ объект, 
source-location. А swank::frame-source-location использует sb-di::code-location. ПО счастью, у них совпадают поля:
sb-di::code-location - %%tlf-offset и %form-number, 
sb-c:DEFINITION-SOURCE-LOCATION - содержит 
   :NAMESTRING "c:/yar/fb2/my-full-eval/interpreted-code-for-test.lisp"
   :TOPLEVEL-FORM-NUMBER 2
   :FORM-NUMBER 3

Если нам повезёт, мы сможем подсунуть одно вместо другого. Вроде примерно это удалось с помощью 
clco::convert-definition-source-location-to-definition-source . 










load-as-source - тоже что-то пытается сделать на тему запоминания исходников. Но пока неясно, как оно может помочь нам. 

План подключения нахождения исходника для интерп.ф-ии:
-------------------------------------------------------
Как нам приделать это к нашему интерпретатору? См. "исследовательский код" ниже. 

Видимо, сделать свою ф-ю по мотивам compile-file, используя
sb-c::with-source-paths. Сохранять путь к каждой подформе вместе с определением интерпретируемой ф-ии. 
Пользоваться этой инф-ей. 

Далее, в определённых местах иметь локальные переменные, указывающие на текущую выполняемую ф-ю и текущую выполняемую форму. 
Выполняя в кадре стека некую ф-ю, можем произвести скачок к месту исходника. Специальные переменные здесь не подходят, т.к.
их значения не зависят от кадра стека (в SBCL). 

Пока что делаем это только для block, т.к. каждая ф-я в себя его включает. 

Что ещё может быть полезным?
----------------------------

Структура sb-c::debug-source: 

;;; There is one per compiled file and one per function compiled at
;;; toplevel or loaded from source.

Как в среде работает команда "перейти к определению"?
----------------
c:/clcon/lp/clcon/lisp-debugger.ldbg.tcl
 ::ldbg::EditFrameSource
   clcon-server:ldbg-edit-frame-source-location
     swank:frame-source-location -> c:/clcon/lp/slime/swank/sbcl.lisp
       sb-di:frame-code-location -- читает из заранее записанной структуры. Где создаётся эта структура - неизвестно. 


Ещё находки
-----------
### sb-c::make-compiler-error-context 
В нём поля :file-position и :original-source-path

### SB-C::MAKE-DEFINITION-SOURCE-LOCATION 
Как работает и когда применяется - непонятно, но как-то работает (defclass, вложенный в progn, как-то находится). 

### swank::find-source-location
ссылается на SB-INTROSPECT:FIND-DEFINITION-SOURCE

Исследовательский код
---------------------

c:/yar/fb2/my-full-eval/debug-eval.lisp - там создаётся ф-я (m::dot), Края выполняет тест.

На данный момент он умеет (вроде бы) записывать и показывать исходник. Как поступим дальше? 
Сделаем по аналогии с расширениями для asdf (показать текущий файл, показать текущую систему) - заведём
macrolet-ы, к-рые в каждом кадре пытаются показать то, что надо. 



