; -*- mode : lisp ; -*-

Lisp-mode для clcon
=====================

Краткая сводка
--
Есть код одуванчика (в прошлом - цикута), написанный на лиспе. Он умеет делать автоотступ, раскраску, подсветку парных скобок, определение текущего символа, жонглирование (aka paredit). Мы работаем в ctext и хотим это туда перетащить. Принято за аксиому, что одуванчик - плохо отлаженный редактор и мы не готовы его отлаживать.

Поэтому обязанности разделены. clcon_text (порождённый snit потомок text или ctext) отвечает почти за всё. одуванчик отвечает только за команды, специфичные для лиспового режима. Работает механизм синхронизации между clcon_text и одуванчиком.

Режимы работы
==========

### Заморозка clcon_text

Заморозка нужна для возможности пережидания задержек на синхронизацию между clcon_text и одуванчиком без подвисания clcon_text. В этом режиме перехватываются события клавиатуры и мыши, способные поменять положение курсора в clcon_text или способные ввести в него данные. Они записываются в очередь. После разморозки события поочерёдно отправляются clcon_text, как будто они произошли чуть позже.

### Режим без одуванчика

В этом режиме команды лисп-режима недоступны (на данный момент попытка их вызова приводит к зависанию clcon_text - FIXME). 

### Режим с одуванчиком

В этом режиме для каждого виджета clcon_text создаётся "зеркальный" буфер в одуванчике. Будем называть clcon_text и зеркальный ему буфер в одуванчике "субъектами", а их совокупность - "парой субъектов". В каждый момент только один из пары субъектов является ведущим. Только для него вызываются функции, модифицирующие текст. Ведущий субъект отправляет ведомому сообщения для синхронизации содержимого. FIXME неплохо бы проверить, чтобы при смене ведущего очередь сообщений была пуста, хотя сейчас и так очень часто проверяется полное совпадение текстов в обоих субъектах. 

### Режим ведущего clcon_text.

Этот режим работает по умолчанию. Источником изменений является clcon_text. В text перекрытывсе функции, меняющие содержимое текста, т.е. события insert, delete (replace тоже нужен, но пока ни разу не понадобился). Каждое из этих событий перед своим выполнением отправляется (асинхронно) в swank, где через несколько очередей передаётся одуванчику для выполнения таких же команд в соответствующем буфере одуванчика. Мы не вызываем функции модификации текста одуванчика иначе, как через этот механизм синхронизации, но это лишь джентльменская договорённость, которую легко нарушить.


### Режим ведущего одуванчика

Этот режим нужно специально включать. Включение происходит всегда со стороны clcon_text. Для начала вызывается ф-я $clcon_text Freeze . После этого пользовательские события не могут поменять текст в clcon_text. Другой защиты от несанкционированной модификации clcon_text у нас нет.

Далее мы должны попасть в точку входа oduvanchik::call-oduvanchik-function-with-clcon_text .Там связывается в истину переменная oduvanchik-internals::*do-editing-on-tcl-side*. Она сообщает одуванчику о том, что теперь он является ведущим (FIXME данный флаг является глобальным. Вообще говоря, он должен быть локальным для каждой пары субъектов. Это понадобится нам, когда мы будем работать более чем с одним буфером одновременно, например, при появлении двух экземлпяров редакторов).

FIXME правильно ли, что мы устанавливаем insert в те координаты, которые пришли в событии? 

Внутри этого вызова выполняется код одуванчика в режиме ведущего одуванчика.

В этом режиме перекрыты все примитивы модификации текста в одуванчике, например, oi::insert-string. Перед внесением изменений в буфер одуванчика они отправляют в tcl синхронную команду (oi::call-tcl-editing) внести такое же изменение в clcon_text. Иногда нужно синхронизировать положение точки вставки, это делается также синхронно, но более легковесной функцией (oi::call-tcl-simple).

Разновидности одуванчика
================
Если проект собран с фичей #+oduvan-invisible , то
одуванчик невидим - присутствуют структуры данных, но без визуализации.
Такой одуванчик является кросс-платформенным. Это production версия.

Если проект собран с #-oduvan-invisible, то он зависит от XLib
и работает только под Linux. Это debug-версия.

Видимый одуванчик - общий порядок обработки
===============


```
clcon_text.tcl -> swank-io.tcl -> text2odu.lisp(*text2odu-event-queue*)->

oduvan1(тред диспетчера в функции clco::text2odu-dispatcher-thread-function
             перекладывает события в очередь *text2odu-dispatcher-to-editor-queue*
             и подсовывает событие нажатия клавиши F8 или другой кнопки в очередь входных событий одуванчика - clco::podsunutq-event
             )

одуванчик изменён, чтобы очередь входных событий опрашивалась через интервал времени,
а не только с помощью событий X. мы не научились отправлять событие в X, да нам это и не
очень надо, раз решение проблемы найдено.

-> oduvanchik-key-bindings.lisp
    обработчик кнопки f8(odu::evaltext2oduevent-command)
      -> eval-text2odu-event.lisp
       odu::eval-pending-text2odu-events
    -> clco-oduvanchik-key-bindings::text2odu-dispatcher-to-editor-queue-pop
    - извлекает события из очереди *text2odu-dispatcher-to-editor-queue* и выполняет его


Архитектура избыточна, но она позволяет :oduvanchik.base
не зависеть по сборке от :clcon-server, а также позволяет clcon_text не зависать при
отсутствии одуванчика (хотя бы в режиме ведущего одуванчика).

Половину, связанную с режимом ведущего одуванчика, не расписываем.
См. oduvanchik::call-oduvanchik-function-with-clcon_text,
oi::call-tcl-simple, oi::call-tcl-editing . 
```

Невидимый одуванчик
===============

Всё то же самое, но в метод
```(defmethod dispatch-events-with-backend ((backend (eql :invisible-connection-backend)))``
       встроен вызов oduvan-invisible-peek-input-event
         -> text2odu-dispatcher-to-editor-queue-peek )```
       

одуванчик изменён, чтобы опрашивать очередь входных событий с помощью 
  odu::eval-pending-text2odu-events :hang t 
    -> clco-oduvanchik-key-bindings::text2odu-dispatcher-to-editor-queue-pop
    - извлекает события из очереди *text2odu-dispatcher-to-editor-queue* и выполняет его


Элементы инфраструктуры для связи пары субъектов
================

/s2/clcon/clcon_text.tcl - функции RoInsert и др. вызывают MaybeSendToLisp -
отправка асинхронного сообщения одуванчику с возможностью назначения продолжения.

MaybeSendToLisp понимает:

Вставку текста переводит их в clco:nti

Удаление текста переводи в clco:notify-oduvan-tcl-text-delete

Создание и удаление буфера: ConstructBackendBuffer и DestroyBackendBuffer
(FIXME DestroyBackendBuffer игнорируется лиспом)
(FIXME не хватает ResyncBackendBuffer после перезапуска одуванчика, но не совсем ясно, как сделать)

CallOduvanchikFunction - передаёт событие clco:call-oduvanchik-function-with-clcon_text - переход в режим ведущего одуванчика, выполнение кода

Также MaybeSendToLisp принимает продолжение far_tcl_continuation, которое будет выполнено после отчёта от swank об обработке события на стороне одуванчика.

WrapEventScriptForFreezedText - ф.в.п для обработки скрипта, чтобы он был совместим с режимом заморозки. Принимает текло скрипта, который должен что-то делать с clcon_text. Обработанный скрипт будет необработанный в очередь, если включён режим заморозки одуванчика.

IncrPendingSentNotifications - меняет локальный и глобальный счётчик отправленных одуванчику соощений, на которые ещё не получен отчёт об их принятии к исполнению (они пропали по дороге или лежат во входной очереди одуванчика. Например, если одуванчик не запущен, эта очередь будет забиваться событиями). Глобальный счётчик считает события удаления буфера, поскольку после выполнения этого события локальный счётчик уже не имеет смысла. 

IncrPendingFarTclContinuations, -private_pending_far_tcl_continuations - функция и опция clcon_text для контроля отчётов о выполнении отправленных через MaybeSendToLisp событий. Содержит количество заказанных данным clcon_text-ом отчётов о выполнении события, которые ещё не выполнены.

Продолжение следует... 

Отладка
========
В редакторе есть меню Secret/Unfreeze, позволяющее разморозить clcon_text.
Если одуванчик отвалился, а потом запущен заново, уже открытые буфера clcon_text ломаются (FIXME поправить это).

Концевой символ перевода строки
========
text всега добавляет его. Надо его игнорировать при отправке текста в одуванчик и при сохранении файла. Тогда он вроде бы не мешает. 


Дополнительные источники информации
--
Дана ссылка на /s2/oduvanchik2/doc/ps/oduvanchik-cim.ps
[Он же в репозитории](https://bitbucket.org/budden/oduvanchik/src/default/doc/ps/oduvanchik-cim.ps?at=default)

Особенности
--


Архитектура одуванчика
--

    Нажатие буквы: /s2/oduvanchik2/src/command.lisp
    
     insert-string , insert-character
     current-point - должно приходить с событием

     oduvanchik-internals::insert-character mark character

     oduvanchik-internals::mark - класс:
       line charpos %kind

     mark-некая структура, ссылающаяся на внутренние структуры odu, в т.ч. 
        на line. 
     Пришёл индекс l.c -> по нему вычислить mark. Как? 
         объект line. 

     mark-line - типа
     oduvanchik-internals::line
       line-chars -> chars
       previous next
       marks
       %buffer - буфер, но может быть и ничем
     number
  
     oduvanchik-internals::buffer
        содержит 
     oduvanchik-internals::region

buffer содержит start и end - две марки. С марков выходим на строку, со строки - на 
  следующую и т.п. Таким образом, поиск строки по номеру занимает линейное время.


### Индексы
oduvanchik-internals::send-mark-to-clcon_text
oduvanchik-internals::sync-mark-from-clcon_text

### 3. Проблемы многопоточности в одуванчике
Вместо мьютексов (или критических секций?) применяется without-interrupts. Это требует решения.

### Ещё о марках. 
Марка может подвинуться при командах редактирования текста, пока с этим проблем не было.
Мы создаём негигиеничные временные марки с фиксированными именами - пока это тоже без проблем.

### Критерии корректной работы задачи заморозки (для тестирования)
Мы можем смоделировать тупёж лиспа следующим путём:

  1. В лиспе запускаем любый (loop (sleep) (print)), чтобы было труднее
  2. Связываем на кнопку F7 алгоритм, который:

     отправляет в лисп (sleep) (eval-in-tcl "insert .text insert "adfjkl")

  3. Отчаянно жмём на кнопки, пытаемся переставить курсор
  4. Должно появиться asdfjkl и только потом наши нажатые кнопки

Более простой вариант - без лиспа. Просто включаем/выключаем режим затупа. В режиме
затупа сообщения пишутся в очередь. При отключении режима затупа - достаются из очереди. 
Режим затупа то включаем, то выключаем, и пробуем при этом что-то печатать и делать мышью. 

#### 4.5. Критерии решения задачи параллельности в одуванчике. 
  Видимо, нужно ставить условные брекпойнты в разных неприятных местах и в это время работать во втором буфере. Или нужно прочитать код, выяснить используемые примитивы блокировки и заменить их на современные. 


### 5. Раскраска (поток сознания): 
видимо, нужно найти примитивы раскраски, которые используются в одуванчике и перешибить их. Все примитивы раскраски, применённые после принятого из tcl редактирования N, должны записываться в очередь. Когда tcl присылает следующее редактирование N+1, мы говорим ему: посоревнуйся сперва с моим младшим братом. Отправляем tcl-ю все примитивы раскраски, он их применяет. После этого мы выполняем в лиспе редактирование N+1. 

Если пользователь не трогает текст, то tcl должен запросить её по таймеру. Пока не пытаемся оптимизировать раскраску, поскольку для файлов до 100 кб она работает достаточно быстро. За счёт блокировки буфера на время обращения к лиспу у нас гарантировано совпадение буферов tcl и одуванчика в процессе обмена данными, значит нет проблемы, что при передаче первой раскраски придёт слишком много данных и раскраска займёт время. 

Реализация Freeze
----
Сложность - перехватить события. Решение - в конструкторе clcon_text 
