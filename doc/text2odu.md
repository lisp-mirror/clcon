; -*- mode : lisp ; -*-

Lisp-mode для clcon
=====================

Краткая сводка
--
Есть код одуванчика (в прошлом - цикута, но пережила духовную трансформацию), написанный на лиспе. Он умеет делать автоотступ, раскраску, подсветку парных скобок, определение текущего символа, жонглирование (aka paredit). Мы работаем в ctext и хотим это туда перетащить. Принято за аксиому, что одуванчик - плохо отлаженный редактор и мы не готовы его отлаживать.

Поэтому обязанности разделены. clcon_text (порождённый snit потомок text или ctext) отвечает почти за всё. одуванчик отвечает только за команды, специфичные для лиспового режима. Работает механизм синхронизации между clcon_text и одуванчиком.

Режимы работы
==========

### Заморозка clcon_text

Заморозка нужна для возможности пережидания задержек на синхронизацию между clcon_text и одуванчиком без подвисания clcon_text. В этом режиме перехватываются события клавиатуры и мыши, способные поменять положение курсора в clcon_text или способные ввести в него данные. Они записываются в очередь. После разморозки события поочерёдно отправляются clcon_text, как будто они произошли чуть позже. А точнее, выполняются назначенные для них скрипты. Здесь есть несколько нюансов:
- команда, которая находится в очереди, сама может вызвать заморозку. Поэтому у нас возникает понятие "уровня блокировки"
- это может произойти в момент, когда мы выполняем события из очереди. Поэтому у нас возникает понятие "состояния блокировки"
- скрипт клавиатуры зачастую вызывает break. Это нужно отдельно обрабатывать в нашей системе, поскольку в момент выполнения скриптов из замороженной очереди нет цикла, из которого можно выйти с помощью break (или это не тот цикл). 

### Режим без одуванчика

В этом режиме команды лисп-режима недоступны (выдаётся сообщение об ошибке). 

### Режим с одуванчиком

В этом режиме для каждого виджета clcon_text создаётся "зеркальный" буфер в одуванчике. Будем называть clcon_text и зеркальный ему буфер в одуванчике "субъектами", а их совокупность - "парой субъектов". В каждый момент только один из пары субъектов является ведущим. Только для него вызываются функции, модифицирующие текст. Ведущий субъект отправляет ведомому сообщения для синхронизации содержимого. FIXME неплохо бы проверить, чтобы при смене ведущего очередь сообщений была пуста, хотя сейчас и так очень часто проверяется полное совпадение текстов в обоих субъектах. 

### Режим ведущего clcon_text.

Этот режим работает по умолчанию. Источником изменений является clcon_text. В text перекрытывсе функции, меняющие содержимое текста, т.е. события insert, delete (replace тоже нужен, но пока ни разу не понадобился). Каждое из этих событий перед своим выполнением отправляется (асинхронно) в swank, где через несколько очередей передаётся одуванчику для выполнения таких же команд в соответствующем буфере одуванчика. Мы не вызываем функции модификации текста одуванчика иначе, как через этот механизм синхронизации, но это лишь джентльменская договорённость, которую легко нарушить.


### Режим ведущего одуванчика


Этот режим нужно специально включать. Включение происходит всегда со стороны clcon_text. Для начала вызывается ф-я $clcon_text Freeze . После этого пользовательские события не могут поменять текст в clcon_text. Другой защиты от несанкционированной модификации clcon_text у нас нет.

FIXME правильно ли, что мы устанавливаем insert в те координаты, которые пришли в событии? 

Внутри этого вызова выполняется код одуванчика в режиме ведущего одуванчика.

В этом режиме перекрыты все примитивы модификации текста в одуванчике, например, oi::insert-string. Перед внесением изменений в буфер одуванчика они отправляют в tcl синхронную команду (oi::call-tcl-editing) внести такое же изменение в clcon_text. Иногда нужно синхронизировать положение точки вставки, это делается также синхронно, но более легковесной функцией (oi::call-tcl-simple).

Разновидности одуванчика
================
Если проект собран с фичей #+oduvan-invisible , то
одуванчик невидим - присутствуют структуры данных, но без визуализации.
Такой одуванчик является кросс-платформенным. Это production версия.

Если проект собран с #-oduvan-invisible, то он зависит от XLib
и работает только под Linux. Это debug-версия.

Также есть фича
(pushnew :use-oduvan-for-first-clcon_text-pathname-only *features*)
она отключает обработку событий одуванчиком от clcon для всех буферов,
кроме первого созданного. Это облегчает отладку самого редактора, когда
выскакивающее окно отладчика и открытие исходного текста не меняют состояние
одуванчика.

Видимый одуванчик - общий порядок обработки
===============


```
 ../clcon_text.tcl -> ../swank-io.tcl -> ../text2odu-from-tcl-to-queue.lisp (*text2odu-event-queue*)->

../text2odu-dispatch-to-oduvan.lisp (тред диспетчера в функции clco::text2odu-dispatcher-thread-function
             перекладывает события в очередь *text2odu-dispatcher-to-editor-queue*
             и подсовывает событие нажатия клавиши F8 или другой кнопки в очередь входных событий одуванчика - clco::podsunutq-event
             )

одуванчик изменён, чтобы очередь входных событий опрашивалась через интервал времени,
а не только с помощью событий X. мы не научились отправлять событие в X, да нам это и не
очень надо, раз решение проблемы найдено.

-> oduvanchik-key-bindings.lisp
    обработчик кнопки f8(odu::evaltext2oduevent-command)
      -> eval-text2odu-event.lisp
       odu::eval-pending-text2odu-events
    -> clco-oduvanchik-key-bindings::text2odu-dispatcher-to-editor-queue-pop
    - извлекает события из очереди *text2odu-dispatcher-to-editor-queue* и выполняет его


Архитектура избыточна, но она позволяет :oduvanchik.base
не зависеть по сборке от :clcon-server, а также позволяет clcon_text не зависать при
отсутствии одуванчика (хотя бы в режиме ведущего одуванчика).

Половину, связанную с режимом ведущего одуванчика, не расписываем.
См. oduvanchik::call-oduvanchik-function-with-clcon_text,
oi::call-tcl-simple, oi::call-tcl-editing . 
```

Невидимый одуванчик
===============

Всё то же самое, но в метод
```(defmethod dispatch-events-with-backend ((backend (eql :invisible-connection-backend)))``
       встроен вызов oduvan-invisible-peek-input-event
         -> text2odu-dispatcher-to-editor-queue-peek )```
       

одуванчик изменён, чтобы опрашивать очередь входных событий с помощью 
  odu::eval-pending-text2odu-events :hang t 
    -> clco-oduvanchik-key-bindings::text2odu-dispatcher-to-editor-queue-pop
    - извлекает события из очереди *text2odu-dispatcher-to-editor-queue* и выполняет его


Элементы инфраструктуры для связи пары субъектов
================

/s2/clcon/clcon_text.tcl - функции RoInsert и др. вызывают MaybeSendToLisp -
отправка асинхронного сообщения одуванчику с возможностью назначения продолжения.

MaybeSendToLisp понимает:

Вставку текста переводит их в clco:nti

Удаление текста переводи в clco:notify-oduvan-tcl-text-delete

Создание и удаление буфера: ConstructBackendBuffer и DestroyBackendBuffer
(FIXME DestroyBackendBuffer игнорируется лиспом)
(FIXME не хватает ResyncBackendBuffer после перезапуска одуванчика, но не совсем ясно, как сделать)

CallOduvanchikFunction - передаёт событие clco:call-oduvanchik-function-with-clcon_text - переход в режим ведущего одуванчика, выполнение кода

Также MaybeSendToLisp принимает продолжение far_tcl_continuation, которое будет выполнено после отчёта от swank об обработке события на стороне одуванчика. Продолжение передаётся путём запоминания продолжения на клиенте и отправки его кода на сервер.

WrapEventScriptForFreezedText - ф.в.п для обработки скрипта, чтобы он был совместим с режимом заморозки. Принимает текло скрипта, который должен что-то делать с clcon_text. Обработанный скрипт кладёт необработанный в очередь, если включён режим заморозки одуванчика. Подразумевается, что этот код будет выполнен после разморозки. Если же режим заморозки не включён, то скрипт выполняется сразу. 

IncrPendingSentNotifications - меняет локальный и глобальный счётчик отправленных одуванчику соощений, на которые ещё не получен отчёт об их принятии к исполнению (они пропали по дороге или лежат во входной очереди одуванчика. Например, если одуванчик не запущен, эта очередь будет забиваться событиями). Глобальный счётчик считает события удаления буфера, поскольку после выполнения этого события локальный счётчик уже не имеет смысла. 

IncrPendingFarTclContinuations, -private_pending_far_tcl_continuations - функция и опция clcon_text для контроля отчётов о выполнении отправленных через MaybeSendToLisp событий. Содержит количество заказанных данным clcon_text-ом отчётов о выполнении события, которые ещё не выполнены.

Продолжение следует... 

Отладка
========

### Просто попробовать заставить работать дальше
В редакторе есть меню Secret/Unfreeze, позволяющее разморозить clcon_text.
Если одуванчик отвалился, а потом запущен заново, уже открытые буфера clcon_text ломаются (FIXME поправить это).


### Отключить все буферы, кроме первого (для отладки)
есть фича
`(pushnew :use-oduvan-for-first-clcon_text-pathname-only *features*)`
она отключает обработку событий одуванчиком от clcon для всех буферов,
кроме первого созданного. Это облегчает отладку самого редактора, когда
выскакивающее окно отладчика и открытие исходного текста не меняют состояние
одуванчика.

.fics buf1 - это тоже надо поискать при использовании этой фичи

### Логи

См. testing.md, пункт "словарь отладочных сообщений"

### Определение биндингов

`..bindtags [ ::edt::c_text ]` - покажет FreezableText
`..bind FreezableText` - покажет сочетания
`..bind FreezableText <Key>` - покажет назначение конкретного биндинга

Нужно не забывать, что в tcl Control-M вызывает обработчик Control-M и M, поэтому у нас есть несколько bindtag-ов, чтобы предотвратить вызов обработчика для M, с именами SingleMod, DoubleMod, NoMod , . 



Концевой символ перевода строки
========
text всега добавляет его. Надо его игнорировать при отправке текста в одуванчик и при сохранении файла. Тогда он вроде бы не мешает. 


Дополнительные источники информации
--
Дана ссылка на /s2/oduvanchik2/doc/ps/oduvanchik-cim.ps
[Он же в репозитории](https://bitbucket.org/budden/oduvanchik/src/default/doc/ps/oduvanchik-cim.ps?at=default)

Особенности
--


Архитектура одуванчика
--

    Нажатие буквы: /s2/oduvanchik2/src/command.lisp
    
     insert-string , insert-character
     current-point - должно приходить с событием

     oduvanchik-internals::insert-character mark character

     oduvanchik-internals::mark - класс:
       line charpos %kind

     mark-некая структура, ссылающаяся на внутренние структуры odu, в т.ч. 
        на line. 
     Пришёл индекс l.c -> по нему вычислить mark. Как? 
         объект line. 

     mark-line - типа
     oduvanchik-internals::line
       line-chars -> chars
       previous next
       marks
       %buffer - буфер, но может быть и ничем
     number
  
     oduvanchik-internals::buffer
        содержит 
     oduvanchik-internals::region

buffer содержит start и end - две марки. С марков выходим на строку, со строки - на 
  следующую и т.п. Таким образом, поиск строки по номеру занимает линейное время.


### Индексы
oduvanchik-internals::send-mark-to-clcon_text
oduvanchik-internals::sync-mark-from-clcon_text

### 3. Проблемы многопоточности в одуванчике
Вместо мьютексов (или критических секций?) применяется without-interrupts. Это требует решения.

### Ещё о марках. 
Марка может подвинуться при командах редактирования текста, пока с этим проблем не было.
Мы создаём негигиеничные временные марки с фиксированными именами - пока это тоже без проблем.

### Критерии корректной работы задачи заморозки (для тестирования)
Мы можем смоделировать тупёж лиспа следующим путём:

  1. В лиспе запускаем любый (loop (sleep) (print)), чтобы было труднее
  2. Связываем на кнопку F7 алгоритм, который:

     отправляет в лисп (sleep) (eval-in-tcl "insert .text insert \"adfjkl\"")

  3. Отчаянно жмём на кнопки, пытаемся переставить курсор
  4. Должно появиться asdfjkl и только потом наши нажатые кнопки

Более простой вариант - без лиспа. Просто включаем/выключаем режим затупа. В режиме
затупа сообщения пишутся в очередь. При отключении режима затупа - достаются из очереди. 
Режим затупа то включаем, то выключаем, и пробуем при этом что-то печатать и делать мышью. 

#### 4.5. Критерии решения задачи параллельности в одуванчике. 
  Видимо, нужно ставить условные брекпойнты в разных неприятных местах и в это время работать во втором буфере. Или нужно прочитать код, выяснить используемые примитивы блокировки и заменить их на современные. 

Реализация Freeze
----
Сложность - перехватить события. Решение - в конструкторе clcon_text 


abort и вложенные вызовы
------
"
tcl->lisp find definition
  lisp - составляет список определений
  если одно определение
    lisp->tcl - перейти к определению
  если несколько
    lisp->tcl - выбери нужное определение
    tcl - ABORT
Как это воплотить при асинхронном режиме обмена сообщениями со стороны tcl?

- в целом несложно. Проблема будет, если отвалился коннект. 
Для этого можно построить граф, кто кого ждёт, и последовательно передавать
исключение во все продолжения. 

Freeze 2.0
----------
### Состояния (option -private_freezed):

0 - unfreezed - весь ввод немедлено выполняется. В биндинге может быть
команда Freeze, а в продолжении, которое он назначает - Unfreeze. 
1 - freezed - идёт работа в лиспе. Ввод кладётся в очередь.
2 - unfreezing - работа в лиспе завершена, происходит обработка очереди событий, 
возникших в ходе заморозки. 

### Уровень заморозки:

option -private_freeze_level
Для рекурсивной заморозки. Детали см. в исходнике. Без уровня не удавалось правильно
поддерживать состояние заморозки, поскольку во время разморозки приходило новое событие заморозки. 


### Возможные проблемы

Пока эти проблемы вроде бы не проявляются, но могут проявиться ещё. 

Проблема возникнет у нас с незамораживающим скриптом, который внутри себя вызывает 
update, или который состоит из нескольких сообщений. Например, Control-O вызывает диалог.
Если Control-O пришло в процессе разморозки, последующие события из очереди отложенных событий проскочат до закрытия диалога. 

Как мы можем защититься? Перекрыть update и запретить его в определённые моменты? Либо ставить Freeze на Control-O.

Может быть скрипт, который кладёт событие на after <ВРЕМЯ> или after idle. Он не вызывает сам по себе update, но update может возникнуть по другой причине и в другом окне. Например, если мы заморозили, а перед этим был скрипт, положивший что-то на after, то может произойти несанкционированное выполнение этого after в процессе разморозки. Что мы с этим сделаем? Видимо, можем только переименовать after. 

Вызов вызов ф-ии одуванчика. Содержит freeze, а после завершения вызывается автоматически Unfreeze или ContinuationBody. 

БИНДИНГИ
=========
Их много и каждый может вызвать проблему. 
Биндинги оборачиваются с помощью WrapEventScriptForFreezedText
процедура ::gui_util::ListAllWindowBindingds
позволяет получить все действующие биндинги. Например, 

Напечатать все. 
`foreach binding [::gui_util::ListAllWindowBindingds [::edt::c_btext]] {puts $binding}`

Напечатать те, к-рые не содержат слова -private_freezed: 

`foreach entry [::gui_util::ListAllWindowBindingds [::edt::c_btext]] { foreach { bindtag binding script } $entry {} ; if { ![regexp -- \\-private_freezed $script] } { puts $entry } }`




Если в биндинге подразумевается break, его нужно вынести наружу обёртки. 
Мы это не умеем, поэтому проверяем отсутствие break, return и continue в скритпе 
( ::clcon_text::CheckIfScriptDoesNotContainBreakContinueOrReturn )

Если есть несколько биндтагов, то во время режима заморозки выполнятся все подходящие
скрипты. Это нужно учитывать, и этим можно пользоваться. 

See also
========
syntax-highlight.md

