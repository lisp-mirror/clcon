; -*- coding : utf-8 ; Encoding : utf-8 ; system :clcon-server ; -*- 

Как происходит связь межд лиспом и tcl/tk?
==========================================
clcon - клиент-серверное приложение. Клиентская сторона написана на tcl/tk
и может функционировать (нарисовать себя на экране, открывать файлы и т.п.) вообще без
всякого лиспа. 

На стороне лиспа используется SWANK. Это сервер, работающий через сокеты, предоставляющий
интерфейс к REPL (Read-Eval-Print loop), метаданным лиспа, отладчику и т.п. SWANK известен
тем, что является основой SLIME. При загрузке лисповой части на SWANK накладывается патч,
который позволяет отличать соединения с clcon от соединений с EMACS и меняющий поведение SWANK при 
соединении с clcon. При этом другое соединение с EMACS может работать как прежде. 

Связь между клиентом и сервером происходит через сокет путём обмена асинхронными сообщениями. 
Сообщение включает в себя тип, содержательную часть (код, команду, возвращаемое значение и т.п.),
а также может включать в себя имя пакета, номер треда на серверной стороне и номер продолжения.
Клиентская часть должна вести таблицу продолжений и по возврату сообщения с таким номером продолжения 
вызывать продолжение. 

[FAQ mode] Какую библиотеку для работы с tcl/tk вы используете?
===============================================================
Почти никакую.  Лисповая сторона не оперирует с объектами tcl/tk, т.к. является лишь сервером
для обработки собственно лисповых данных. Код для работы с tk написан на tcl/tk и хранится
в файлах \*.tcl. Поэтому нам не нужны лисповые обёртки для виджетов tk. Иногда мы всё же 
генерируем код tcl на лисповой стороне и тогда используем одну-две функции из [cl-tk](http://marijnhaverbeke.nl/cl-tk/).
См. "формат обмена данными".

Формат обмена данными
=====================
Используется собственный формат, позволяющий кодировать печатное представление лисповых объектов
в той степени, в которой это достаточно для работы SWANK. SWANK использует достаточно узкое подмножество
синтаксиса s-выражений. S-выражения не так удобно разбирать на стороне tcl, мы используем свой формат, см. 
[cons.tcl](../cons.tcl),[cons.md](cons.md). Данный формат позволяет на стороне tcl определять структуру и тип переданных 
лисповых данных. Генерация лиспового кода на стороне tcl происходит путём обычного форматирования строк,
также имеется функция (требующая полной переработки) для закавычивания данных, чтобы они не повредились 
при передаче. Иногда мы генерируем tcl-ный код на стороне лиспа и отправляем в tcl команду выполнить этот код. 
Соответствующий функционал лиспа - в [пакете clcon-server](../package.lisp), в т.ч. здесь [swank-patch.lisp](../swank-patch.lisp).

Для закавычивания строк при отправке в tcl используется функция из cl-tk.

Как писать код взаимодействия tcl/tk <-> SWANK? 
================================================

Построение системы
------------------
Пока что мы подразумеваем, что у нас есть единственное соединение IDE со SWANK.
Это позволяет хранить сведения о соединении глобально. Возможно, это так и останется навсегда.

Формат данных
-------------
Формат - согласно [cons.md](cons.md)

Асинхронные сообщения lisp->tcl
--------------------------------
Сообщения приходят из потока и кладутся в очередь. Далее они обрабатываются через механизм
событий tk. Если в данное время выполняется синхронный обмен, асинхронные сообщения от лиспа 
откладываются до завершения синхронного обмена (не думаю, что это есть в SLIME). 

В простейшем случае "Спонтанные сообщения" могут приказывать IDE выполнить определённые действия. Типичный пример - 
печать строки в *standard-output* порождает сообщение 
    (:write-string "some string")
IDE принимает это сообщение и пишет строку в консоль. 

Асинхронный вызов tcl->lisp
--------------------------
Это базовая форма взаимодействия. tcl отправляет лиспу сообщение с номером продолжения.
Номеру может быть назначена функция продолжения, написанная на tcl. 
Эта функция (на стороне tcl) записывается в ::mprs::ContinuationsDict

Когда от лиспа придёт ответ с таким же номером продолжения, продолжение вызывается, 
а событие передаётся ему в качестве аргумента. Нужно учесть, что это происходит 
в цикле обработки очереди сообщений, поэтому функция продолжения не должна выполняться
долго. Например, она может кидать событие в очередь событий tk. 

Возможная проблема: ответ на сообщение всегда должен придти. Я не знаю, так ли это на самом деле. 
Если ответ не приходит, продолжение навсегда останется в режиме ожидания и засоряет ContinuationsDict.
Решение: выводить в статус баре красную цифру, если слишком много продолжений ожидает.

Синхронный вызов tcl->lisp
-------------------------
Синхронный вызов меняет порядок работы с сообщениями. Выставляется в 1 переменная ::tkcon::SWANKIsInSyncMode
После этого все приходящие асинхронные сообщения откладываются до завершения 
синхронного режима. Синхронный вызов не реентерабелен, стоит assert на попытку повторного входа в синхронный режим. Однако ожидание ответа в синхронном вызове реализовано с помощью vwait, что позволяет IDE не зависать, и поэтому могут происходить плохие вещи, в т.ч. попытка повторного входа в синхронный режим, закрытие окна и т.п. Наверное, надо это переделать.

Попробовать busy?


Если нет, то: просто убрать vwait нельзя, тогда мы не сможем
отменить синхронный вызов со стороны IDE. Не знаю, что делать. Надо было бы по идее сделать что-то типа
модального диалога, и делать синхронный вызов из этого диалога, но тогда этот диалог будет мелькать, а это неприемлемо для таких вещей, как completion. Возможно, мы можем не ставить vwait, висеть на чтении
из потока, а отмену реализовать как обработчик сигнала. Но неизвестно, является ли это кроссплатформенным решением. 

В итоге, в настоящее время порядок взаимодействия при синхронном вызове такой:

    tcl -> lisp ; синхронный вызов
    wvait
    lisp -> tcl ; возврат синхронного ответа

Ответ на наше сообщение мы отличаем по коду продолжения, как при асинхронном вызове, но назначить продолжение на синхронный вызов нельзя, поскольку вся обработка происходит в одной процедуре tcl и это просто не нужно. Нужные действия делаются после возврата из синхронного вызова. 

Мы пока не поддерживаем сообщение :abort , но вроде оно вписывается в нашу модель. 


Полная модель синхронного вызова подразумевает диалог
с возможностью нелокального возврата:

    tcl -> lisp ; синхронный вызов
     lisp -> tcl ; синхронный обратный вызов
      lisp -> tcl ; синхронный вызов     
       (return-from) ; нелокальный возврат
    lisp -> tcl ; нелокальный возврат 

В SWANK/SLIME такая модель есть. У нас такой модели нет и мы постараемся 
её избежать. 

Другой вариант подразумевает отмену вызова со стороны клиента:

    tcl -> lisp ; синхронный вызов
    tcl -> lisp ; отмена вызова
    
Этого у нас нет, но это необходимо сделать. 
          
Паттерны
--------
### Completion ### 
Использует простой синхронный вызов

    tcl -> lisp ; вызов
    lisp -> tcl ; возврат

ДАЛЬШЕ ПОШЁЛ ЧЕРНОВИК, ПРОДОЛЖЕНИЕ СЛЕДУЕТ! 
===========================================

### Eval ###
Последовательность асинхронных вызовов

На какой стороне писать код? 
--------------------
- Непосредственно написанный в файле код проще поддерживать, чем сгенерённый
- Если уже есть хороший код, его надо использовать
- Большие куски кода на tcl желательно хранить в файле, а не генерировать
