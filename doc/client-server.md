Как писать код взаимодействия tcl/tk <-> SWANK? 
================================================

Имеется перекрытие возможностей между клиентом и сервером. Что делать?

Построение системы
------------------
Пока что мы подразумеваем, что у нас есть единственное соединение IDE со SWANK.
Это позволяет хранить сведения о соединении глобально. Возможно, это так и останется навсегда.

Формат данных
-------------
Формат - согласно (cons.md)[cons.md]


Асинхронные сообщения lisp->tcl
--------------------------------
Сообщения приходят из потока и кладутся в очередь. Далее они обрабатываются через механизм
событий tk. Если в данное время выполняется синхронный обмен, асинхронные сообщения от лиспа 
откладываются до завершения синхронного обмена (не думаю, что это есть в SLIME). 

В простейшем случае "Спонтанные сообщения" могут приказывать IDE выполнить определённые действия. Типичный пример - 
печать строки в *standard-output* порождает сообщение 
    (:write-string "some string")
IDE принимает это сообщение и пишет строку в консоль. 

Асинхронный вызов tcl->lisp
--------------------------
Это базовая форма взаимодействия. tcl отправляет лиспу сообщение с номером продолжения.
Номеру может быть назначена функция продолжения, написанная на tcl. 
Эта функция (на стороне tcl) записывается в ::mprs::ContinuationsDict

Когда от лиспа придёт ответ с таким же номером продолжения, продолжение вызывается, 
а событие передаётся ему в качестве аргумента. Нужно учесть, что это происходит 
в цикле обработки очереди сообщений, поэтому функция продолжения не должна выполняться
долго. Например, она может кидать событие в очередь событий tk. 

Возможная проблема: ответ на сообщение всегда должен придти. Я не знаю, так ли это на самом деле. 
Если ответ не приходит, продолжение навсегда останется в режиме ожидания и засоряет ContinuationsDict.
Решение: выводить в статус баре красную цифру, если слишком много продолжений ожидает.

Синхронный вызов tcl->lisp
-------------------------
Синхронный вызов меняет порядок работы с сообщениями. Выставляется в 1 переменная ::tkcon::SWANKIsInSyncMode
После этого все приходящие асинхронные сообщения откладываются до завершения 
синхронного режима. Синхронный вызов не реентерабелен, стоит assert на попытку повторного входа в синхронный режим. Однако ожидание ответа в синхронном вызове реализовано с помощью vwait, что позволяет IDE не зависать, и поэтому могут происходить плохие вещи, в т.ч. попытка повторного входа в синхронный режим, закрытие окна и т.п. Наверное, надо это переделать. Просто убрать vwait нельзя, тогда мы не сможем
отменить синхронный вызов со стороны IDE. Не знаю, что делать. Надо было бы по идее сделать что-то типа
модального диалога, и делать синхронный вызов из этого диалога, но тогда этот диалог будет мелькать, а это неприемлемо для таких вещей, как completion. Возможно, мы можем не ставить vwait, висеть на чтении
из потока, а отмену реализовать как обработчик сигнала. Но неизвестно, является ли это кроссплатформенным решением. 

В итоге, в настоящее время порядок взаимодействия при синхронном вызове такой:

    tcl -> lisp ; синхронный вызов
    wvait
    lisp -> tcl ; возврат синхронного ответа

Ответ на наше сообщение мы отличаем по коду продолжения, как при асинхронном вызове, но назначить продолжение на синхронный вызов нельзя, поскольку вся обработка происходит в одной процедуре tcl и это просто не нужно. Нужные действия делаются после возврата из синхронного вызова. 

Мы пока не поддерживаем сообщение :abort , но вроде оно вписывается в нашу модель. 


Полная модель синхронного вызова подразумевает диалог
с возможностью нелокального возврата:

    tcl -> lisp ; синхронный вызов
     lisp -> tcl ; синхронный обратный вызов
      lisp -> tcl ; синхронный вызов     
       (return-from) ; нелокальный возврат
    lisp -> tcl ; нелокальный возврат 

В SWANK/SLIME такая модель есть. У нас такой модели нет и мы постараемся 
её избежать. 

Другой вариант подразумевает отмену вызова со стороны клиента:

    tcl -> lisp ; синхронный вызов
    tcl -> lisp ; отмена вызова
    
Этого у нас нет, но это необходимо сделать. 
          
Паттерны
--------
### Completion ### 
Использует простой синхронный вызов

    tcl -> lisp ; вызов
    lisp -> tcl ; возврат

ДАЛЬШЕ ПОШЁЛ ЧЕРНОВИК, ПРОДОЛЖЕНИЕ СЛЕДУЕТ! 
===========================================

### Eval ###
Последовательность асинхронных вызовов

На какой стороне писать код? 
--------------------
- Непосредственно написанный в файле код проще поддерживать, чем сгенерённый
- Если уже есть хороший код, его надо использовать
- Большие куски кода на tcl желательно хранить в файле, а не генерировать
