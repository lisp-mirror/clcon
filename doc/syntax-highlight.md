; -*- mode : lisp ; -*-

Раскраска (старая версия)
=========


### Текущее использование раскраски


oi::line-tag -> ... -> oi::recompute-syntax-marks -> clco::notify-highlight-single-line -> кладёт в очередь

вызывается из: oi::line-syntax-info, odu::package-at-point, oi::sync-dis-line-tag -
из них sync-dis-line-tag отключил (и ещё что-то отключил).

#### Package-at-point
Мы должны синхронно докрасить до этой точки - odu::package-at-point -> oi::line-tag 

#### Любое редактирование
Мы должны всё перекрасить от начала редактирования до конца файла.
.

#### Открываем файл
Должны всё покрасить, можно асинхронно. Это происходит благодаря вставке.

#### Встали на скобку
Должны докрасить до этого места (асинхронно, потому что иначе зависнем) и _ПОСЛЕ_ЭТОГО
вызвать ф-ю для раскраски скобок, И ЕЩЁ ПОСЛЕ ЭТОГО отправить эти две строчки в tcl.
Дальше можно не красить. 

#### А если процесс раскраски сейчас идёт, и вызвали package-at-point?
Приемлемый вариант: отменить текущую раскраску где она остановилась и считать, что её не было. За счёт пропуска уже покрашенного будет достаточно быстро.

#### А если процесс раскраски сейчас идёт, и вызвали редактирование?
Приемлемо: отменить текущую раскраску и начать с начала файла.
Самое главное: фоновая раскраска должна быть отменена до начала редактирования - а то
уже попали на строчку без буфера в момент удаления. 

#### А если процесс раскраски сейчас идёт, и встали на скобку?
Если наше место уже покрашено, то прервать любой процесс раскраски и
начать с нашей открыв. скобки.

Если оно ещё не покрашено, то мы, наверное, и не можем узнать, какую скобку красить.
Дождаться, пока покраска дойдёт до нас, а далее см. предыдущий случай. 

### Раскраска скобок
При последней работе над кодом в скобки не смотрел. Но они как-то делаются. 
Вроде бы если при попытке раскрасить текущую скобку выясняется, что текущая строка не докрашена,
то мы ничего и не красим. Пользователю придётся подождать, пока раскраска дойдёт до этого места - 
только после этого подсветка парных скобок начнёт работать должным образом. 


Два сценария раскраски - фоновый и синхронный
--------------
Мы вырезали куски из старого "видимого одуванчика", к-рый сложнее за счёт своего undo. 
Мы его отключаем и контролируем, что оно отключено. У нас есть следующие примитивы:

-- oi::line-tag - синхронно вычисляет до текущего места. В реальности вычисление осуществляет 
      oi::recompute-line-tag
-- oi::line-tag-valid-p - проверяет, правильно ли прокрашена текущая строка.
-- oi::update-tag-line-number - сбрасывает раскраску до текущего места и заботится, чтобы процесс фоновой раскраски запустился. 

See also
========
text2odu.md
