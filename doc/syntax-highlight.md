; -*- mode : lisp ; -*-

Раскраска (старая версия)
=========


### Текущее использование раскраски


oi::line-tag -> ... -> oi::recompute-syntax-marks -> clco::notify-highlight-single-line -> кладёт в очередь

вызывается из: oi::line-syntax-info, odu::package-at-point, oi::sync-dis-line-tag -
из них sync-dis-line-tag отключил (и ещё что-то отключил).

#### Package-at-point
Мы должны синхронно докрасить до этой точки - oi::line-tag -> recompute-tags-up-to синхр.
Дальше можно не красить. 

#### Любое редактирование
Мы должны всё перекрасить от начала редактирования до конца файла.
Для упрощения можем перекрашивать всё от начала файла, поскольку там, где ничего
не изменилось, это будет просто проверка подписей. Можно делать синхронно, пока не
попалась первая изменнёная строчка, и после этого переходить в асинхронный режим.

#### Открываем файл
Должны всё покрасить, можно асинхронно

#### Встали на скобку
Должны докрасить до этого места (асинхронно, потому что иначе зависнем) и _ПОСЛЕ_ЭТОГО
вызвать ф-ю для раскраски скобок, И ЕЩЁ ПОСЛЕ ЭТОГО отправить эти две строчки в tcl.
Дальше можно не красить. 

#### А если процесс раскраски сейчас идёт, и вызвали package-at-point?
Приемлемый вариант: отменить текущую раскраску где она остановилась и считать, что её не было. За счёт пропуска уже покрашенного будет достаточно быстро.

#### А если процесс раскраски сейчас идёт, и вызвали редактирование?
Приемлемо: отменить текущую раскраску и начать с начала файла.
Самое главное: фоновая раскраска должна быть отменена до начала редактирования - а то
уже попали на строчку без буфера в момент удаления. 

#### А если процесс раскраски сейчас идёт, и встали на скобку?
Если наше место уже покрашено, то прервать любой процесс раскраски и
начать с нашей открыв. скобки.

Если оно ещё не покрашено, то мы, наверное, и не можем узнать, какую скобку красить.
Дождаться, пока покраска дойдёт до нас, а далее см. предыдущий случай. 

### какие примитивы в итоге нужны?

- (сделано) возможность узнать, докрасили ли до данной строки? Видимо, с помощью buffer

Ещё одно: при отправке в лисп, перед получением line-tag, проверять, валиден ли он.
Если не валиден, падать с ошибкой.

пример куска кода для проверки валидности:
``(let* ((level (buffer-tag-line-number (line-buffer line)))
       (validp (< (line-number line) level)))
  ...)``
                
- установка триггера на условие в ходе раскраски
Можно тупо вбить триггер в сам код раскраски, а можно сделать программируемые триггеры.
Какие могут быть триггеры?
-- уже известный: если дошли до текущей точки и она на скобке, то заняться скобками.
-- фантастический: дошли до конца экрана - можно отправлять более крупными блоками
- (сделано) код волны - для отмены предыдущей раскраски

В реальности сделаем проще:
Если при попытке раскрасить текущую скобку выясняется, что текущая строка не докрашена,
то мы ничего и не красим. Пользователю придётся подождать, пока раскраска дойдёт до этого места. 


Два сценария раскраски - фоновый и синхронный
--------------
Точка входа осталась у нас одна - line-tag -> oi::recompute-tags-up-to
В видимом одуванчике их больше. 
Есть два варианта:
- фоновый запуск - ни на что не влияет, должен быть способ его отменить.
мы должны запускать фоновую раскраску после каждого редактирования, указав начальную строку.
Раскраска всегда идёт до конца файла, т.к. вставленная кавычка перекрашивает весь текст до конца файла. 

Раскраску в основном кидаем во входную очередь ( odu::recompute-line-tags-starting-from-line-background ) , хотя часть делаем сразу (с надеждой, что не сломается).

Также (потом будет) функция отменить фоновый процесс раскраски, если что-то поменялось. План реализации отмены написан в ошибке #102 . Топологику надо продумать. 
                                                                 
- принудительный запуск - когда мы должны дождаться результата. Например, из package-at-point. 


Подсветка скобок
------------
odu::maybe-highlight-open-parens - a redisplay hook that matches parens by highlighting the corresponding open-paren after a close-paren is typed

вопрос в том, вызывается ли он при хождении по скобкам?
Ответ: вызывается, но работает только для закрывающей скобки. С открывающей - извините.
А показывает только открывающую. Пока пусть будет так.

В результате вызывается odu::set-open-paren-font-marks, к-рая устанавливает
две фонтовые марки. Это прекрасно. Но что делать с процессом покраски?
Видимо, они должны как-то суммироваться с результатом раскраски, ведь иначе раскраска затрёт их.

Пока сделал так:

1. odu::encode-marks-for-line берёт марки из строки, а не из syntax-info. Вроде работает.
2. при перекраске скобок соответствующие строки сразу отправляются в clcon, не через
очередь событий одуванчика.

See also
========
text2odu.md
