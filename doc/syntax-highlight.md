; -*- mode : lisp ; -*-

Раскраска (старая версия)
=========


### Раскраска в лиспе

oi::update-tag-line-number  говорит о том, что эта и следующие строки требуют перевычисления. 

Получение тега - oi::line-tag, к-рый вызывает последовательность явлений:

````
oi::line-tag 
  Если тег устарел, то:
  oi::recompute-tags-up-to * nil (синхронно)
    в цикле:
    oi::recompute-line-tag
      oi::recompute-line-tag-inner-1
        oi::recompute-syntax-marks 
          oi::recompute-font-marks-fn-for-line
            oduvanchik::recompute-syntax-marks-function 
              значение переменной "Recompute Syntax Marks Function" в режиме. 
              это - ф-я, к-рая перевычисляет тег для данной строки и возвращает истину, если что-то поменялось. На входе и выходе - состояние лексера. 
          - возвращает истину, если что-то поменялось, и тогда вызывается
        clco::notify-highlight-single-line -> кладёт в очередь событий, откуда уже хода назад нет. 
      oi::recompute-tags-up-to * t
    oi::ПЕРЕРАСКРАСИТЬ-БУФЕР
      oi::recompute-tags-up-to * t (асинхронно)
        в цикле, проходящем через очередь: 
        oduvanchik::recompute-line-tags-starting-from-line-background
          oi::line-tag
````

#### Package-at-point
Мы должны синхронно докрасить до этой точки - odu::package-at-point -> oi::line-tag 

#### Любое редактирование
Мы должны всё перекрасить от начала редактирования до конца файла.

#### Открываем файл
Должны всё покрасить, можно асинхронно. Это происходит благодаря вставке.

#### Встали на скобку
Должны докрасить до этого места (асинхронно, потому что иначе зависнем) и _ПОСЛЕ_ЭТОГО
вызвать ф-ю для раскраски скобок, И ЕЩЁ ПОСЛЕ ЭТОГО отправить эти две строчки в tcl.
Дальше можно не красить. 

#### А если процесс раскраски сейчас идёт, и вызвали package-at-point?
Приемлемый вариант: отменить текущую раскраску где она остановилась и считать, что её не было. За счёт пропуска уже покрашенного будет достаточно быстро.

#### А если процесс раскраски сейчас идёт, и вызвали редактирование?
Приемлемо: отменить текущую раскраску и начать с начала файла.
Самое главное: фоновая раскраска должна быть отменена до начала редактирования - а то
уже попали на строчку без буфера в момент удаления. 

#### А если процесс раскраски сейчас идёт, и встали на скобку?
Если наше место уже покрашено, то прервать любой процесс раскраски и
начать с нашей открыв. скобки.

Если оно ещё не покрашено, то мы, наверное, и не можем узнать, какую скобку красить.
Дождаться, пока покраска дойдёт до нас, а далее см. предыдущий случай. 

### Раскраска в Яре

Имеется переменная режима "Syntax Highlight Mode", к-рая может иметь два значения -
:send-highlight-from-recompute-line-tag - традиционное
:send-highlight-after-recomputing-entire-buffer - для Яра.

В случае Яра
Запускаем лексер синхронно, полностью раскрашиваем все строки внутри oi::line-tag -> oduvanchik-internals::recompute-syntax-marks
Затем запускаем отдельно фоновую раскраску: oduvanchik::start-background-repaint-after-recomputing-entire-buffer

### А как хотим переделать?
В принципе надо хранить, что мы отправляли в прошлый раз. Когда дело фактически дошло до отправки, может оказаться, что строка
дважды мигнула и уже ничего не нужно отправлять. Естественно, если содержимое строки изменилось, нужно забыть, что мы что-то отправляли. 
Также нужно сначала отправлять видимые строчки, а потом уже все остальные, текущий буфер, а затем остальные. Далее, не нужно идти 
по строчкам вперёд - нужно просто периодически искать неотправленные строчки и отправлять их. Но это в светлом будущем. 

### Раскраска скобок
При последней работе над кодом в скобки не смотрел. Но они как-то делаются (не в Яре). 
Вроде бы если при попытке раскрасить текущую скобку выясняется, что текущая строка не докрашена,
то мы ничего и не красим. Пользователю придётся подождать, пока раскраска дойдёт до этого места - 
только после этого подсветка парных скобок начнёт работать должным образом. 


Два сценария раскраски - фоновый и синхронный
--------------
Мы вырезали куски из старого "видимого одуванчика", к-рый сложнее за счёт своего undo. 
Мы его отключаем и контролируем, что оно отключено. У нас есть следующие примитивы:

-- oi::line-tag - синхронно вычисляет до текущего места. В реальности вычисление осуществляет 
      oi::recompute-line-tag
-- oi::line-tag-valid-p - проверяет, правильно ли прокрашена текущая строка.
-- oi::update-tag-line-number - сбрасывает раскраску до текущего места и заботится, чтобы процесс фоновой раскраски запустился. 

See also
========
text2odu.md
