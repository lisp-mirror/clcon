; -*- mode : lisp ; -*-

Раскраска (старая версия)
=========

Видимо, нужно найти примитивы раскраски, которые используются в одуванчике и перешибить их. Все примитивы раскраски, применённые после принятого из tcl редактирования N, должны записываться в очередь. Когда tcl присылает следующее редактирование N+1, мы говорим ему: посоревнуйся сперва с моим младшим братом. Отправляем tcl-ю все примитивы раскраски, он их применяет. После этого мы выполняем в лиспе редактирование N+1. 

Если пользователь не трогает текст, то tcl должен запросить её по таймеру. Пока не пытаемся оптимизировать раскраску, поскольку для файлов до 100 кб она работает достаточно быстро. За счёт блокировки буфера на время обращения к лиспу у нас гарантировано совпадение буферов tcl и одуванчика в процессе обмена данными, значит нет проблемы, что при передаче первой раскраски придёт слишком много данных и раскраска займёт время. 


Раскраска (новая версия)
=========
Видимо, примитивы были выбраны неудачно. Попробуем по-другому.
Со стороны перерисовки

odu::update-window-image -> oi::maybe-change-window (macro) -> oi::compute-line-image -> oi::compute-normal-line-image

oi::compute-line-image -> oi::sync-dis-line-tag -...-> oi::line-tag -> oi::recompute-tags-up-to -> oi::recompute-syntax-marks

В этой цепочке не затронуты строчки после текущей. 

Проблема с oi::compute-normal-line-image - в том, что строки иногда переносятся.
В худшем случае получим ооооооочень длинную строку. Кроме того, при несовпадении размеров буфера получится, что одуванчик отрисует не всю строку.

Но oi::line-tag тут не затронут.
Поэтому точка входа выглядит выбранной верно. Единственное, нужно перерисовывать и вперёд, а это у нас не сделано. 


See also
========
text2odu.md
