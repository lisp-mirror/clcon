; -*- mode : lisp ; -*-

Раскраска (старая версия)
=========

Видимо, нужно найти примитивы раскраски, которые используются в одуванчике и перешибить их. Все примитивы раскраски, применённые после принятого из tcl редактирования N, должны записываться в очередь. Когда tcl присылает следующее редактирование N+1, мы говорим ему: посоревнуйся сперва с моим младшим братом. Отправляем tcl-ю все примитивы раскраски, он их применяет. После этого мы выполняем в лиспе редактирование N+1. 

Если пользователь не трогает текст, то tcl должен запросить её по таймеру. Пока не пытаемся оптимизировать раскраску, поскольку для файлов до 100 кб она работает достаточно быстро. За счёт блокировки буфера на время обращения к лиспу у нас гарантировано совпадение буферов tcl и одуванчика в процессе обмена данными, значит нет проблемы, что при передаче первой раскраски придёт слишком много данных и раскраска займёт время. 


Раскраска (новая версия)
=========
Видимо, примитивы были выбраны неудачно. Попробуем по-другому.
Со стороны перерисовки

odu::update-window-image -> oi::maybe-change-window (macro) -> oi::compute-line-image -> oi::compute-normal-line-image

oi::compute-line-image -> oi::sync-dis-line-tag -...-> oi::line-tag -> oi::recompute-tags-up-to -> oi::recompute-syntax-marks

В этой цепочке не затронуты строчки после текущей. 

Проблема с oi::compute-normal-line-image - в том, что строки иногда переносятся.
В худшем случае получим ооооооочень длинную строку. Кроме того, при несовпадении размеров буфера получится, что одуванчик отрисует не всю строку.

Но oi::line-tag тут не затронут.
Поэтому точка входа выглядит выбранной верно. Единственное, нужно перерисовывать и вперёд, а это у нас не сделано. 

как будет?
=========

Что уже поменяли?
----------------
после вставки всего текста точка находится в конце буфера. Вызывалось
update-modelines-for-buffer, для него вызывался package-at-point,
он вызывал op::line-tag , поэтому происходила полная перераскраска. 

Что теперь делать?
----------------
1. Нужно запустить фоновую раскраску после открытия файла. Видимо, в отдельном треде. Видимо, нужно блокировать момент записи. 
2. После каждого редактирования нужно сбрасывать существующую раскраску и заново запускать овую.

Можно ли использовать существующий тред диспетчера раскраски?

Как сейчас работает?

oi::line-tag -> ... -> oi::recompute-syntax-marks -> clco::notify-highlight-single-line -> кладёт в очередь

вызывается из: oi::line-syntax-info, odu::package-at-point, oi::sync-dis-line-tag -
из них sync-dis-line-tag отключил (и ещё что-то отключил).

Т.е. можно сказать ниоткуда не вызывается. 


Какие варианты
--------------
Точка входа осталась у на одна - line-tag.
Есть два варианта:
- фоновый запуск - ни на что не влияет, должен быть способ его отменить.
мы должны запускать фоновую раскраску после каждого редактирования, указав диапазон, где
нужно обязательно всё переделать, а где можно так оставить (хотя вроде это и так получится, т.е. можно всегда раскрашивать до конца)

- принудительный запуск - когда мы должны дождаться результата.


Как сделать? Наверное, проще всего через подброс самому себе команды "раскрась следующую строчку". Видимо, это нужно в цикле событий делать. В противном случае придётся делать многопоточный редактор и решать вопрос блокировок для абсолютно каждой ф-ии редактора.

Точка входа - odu::eval-pending-text2odu-events

Как избежать дедлоков здесь???? Вопрос пока открыт. Например, можно кидать сообщение во входную очередь, которая принимает сообщения из tcl. 

Тогда получаем, что есть одна функция "пересчитать-теги-по" с параметром "фоново".
Если фоново, она бросает сообщение на пересчёт тега каждой следующей строки и возвращается.
Иначе она возвращается после полного пересчёта. Это будет ф-я oi::recompute-tags-up-to

Также (потом будет) функция отменить "раскраски со строки... "
И видимо тут нужен какой-то счётчик, чтобы функция отмены действовала только на более ранние
функции раскраски. 



See also
========
text2odu.md
