; -*- mode : lisp ; -*-

Раскраска (старая версия)
=========


### Текущее использование раскраски

oi::update-tag-line-number  говорит о том, что эта и следующие строки требуют перевычисления. 

Получение тега - oi::line-tag, к-рый вызывает последовательность явлений:

````
oi::line-tag 
  Если тег устарел, то:
  oi::recompute-tags-up-to * nil (синхронно)
    в цикле:
    oi::recompute-line-tag
      oi::recompute-line-tag-inner-1
        oi::recompute-syntax-marks 
          oi::recompute-font-marks-fn-for-line
            oduvanchik::recompute-syntax-marks-function 
              значение переменной "Recompute Syntax Marks Function" в режиме. 
              это - ф-я, к-рая перевычисляет тег для данной строки и возвращает истину, если что-то поменялось. На входе и выходе - состояние лексера. 
          - возвращает истину, если что-то поменялось, и тогда вызывается
        clco::notify-highlight-single-line -> кладёт в очередь событий, откуда уже хода назад нет. 
      oi::recompute-tags-up-to * t
    oi::ПЕРЕРАСКРАСИТЬ-БУФЕР
      oi::recompute-tags-up-to * t (асинхронно)
        в цикле, проходящем через очередь: 
        oduvanchik::recompute-line-tags-starting-from-line-background
          oi::line-tag
````
### А как хотим переделать?
В принципе надо бы не отправлять повторно, если строка мигнула, но сейчас не до этого. 
Поэтому для буфера Яра:
-- update-tag-line-number обнуляет весь буфер 
-- recompute-syntax-marks всегда возвращает истину, как будто раскраска поменялась. При этом, вычисление делается только в том случае, если буфер помечен как нераскрашенный. Запускается лексер и парсер. 

 ИТАК. 
1. Определить, буфер устарел ли?
2. Сделать полную раскраску. 


#### Package-at-point
Мы должны синхронно докрасить до этой точки - odu::package-at-point -> oi::line-tag 

#### Любое редактирование
Мы должны всё перекрасить от начала редактирования до конца файла.
.

#### Открываем файл
Должны всё покрасить, можно асинхронно. Это происходит благодаря вставке.

#### Встали на скобку
Должны докрасить до этого места (асинхронно, потому что иначе зависнем) и _ПОСЛЕ_ЭТОГО
вызвать ф-ю для раскраски скобок, И ЕЩЁ ПОСЛЕ ЭТОГО отправить эти две строчки в tcl.
Дальше можно не красить. 

#### А если процесс раскраски сейчас идёт, и вызвали package-at-point?
Приемлемый вариант: отменить текущую раскраску где она остановилась и считать, что её не было. За счёт пропуска уже покрашенного будет достаточно быстро.

#### А если процесс раскраски сейчас идёт, и вызвали редактирование?
Приемлемо: отменить текущую раскраску и начать с начала файла.
Самое главное: фоновая раскраска должна быть отменена до начала редактирования - а то
уже попали на строчку без буфера в момент удаления. 

#### А если процесс раскраски сейчас идёт, и встали на скобку?
Если наше место уже покрашено, то прервать любой процесс раскраски и
начать с нашей открыв. скобки.

Если оно ещё не покрашено, то мы, наверное, и не можем узнать, какую скобку красить.
Дождаться, пока покраска дойдёт до нас, а далее см. предыдущий случай. 

### Раскраска скобок
При последней работе над кодом в скобки не смотрел. Но они как-то делаются. 
Вроде бы если при попытке раскрасить текущую скобку выясняется, что текущая строка не докрашена,
то мы ничего и не красим. Пользователю придётся подождать, пока раскраска дойдёт до этого места - 
только после этого подсветка парных скобок начнёт работать должным образом. 


Два сценария раскраски - фоновый и синхронный
--------------
Мы вырезали куски из старого "видимого одуванчика", к-рый сложнее за счёт своего undo. 
Мы его отключаем и контролируем, что оно отключено. У нас есть следующие примитивы:

-- oi::line-tag - синхронно вычисляет до текущего места. В реальности вычисление осуществляет 
      oi::recompute-line-tag
-- oi::line-tag-valid-p - проверяет, правильно ли прокрашена текущая строка.
-- oi::update-tag-line-number - сбрасывает раскраску до текущего места и заботится, чтобы процесс фоновой раскраски запустился. 

See also
========
text2odu.md
