; -*- Coding: utf-8 ; mode : lisp ; -*-
(in-package :swank)


Когда набиваем, консоль сразу пытается понять, что мы набиваем. И делает она это так:
bind TkConsolePost <KeyPress>
 -> ::tkcon::TagProc
   -> EvalAttached [list info proc]
      -> EvalInSwank 


Порядок инициализации
tkcon::AtSource 
  Init 
    InputUI 
      InitMenus 
      Bindings
    OuterAttachToSwank
   
::tkcon::MainInit - вызывается только в главном интерпрететаторе, не в рабах.

порядок вызова команды
  Eval - выполняет то, что ввёл пользователь
    CmdGet
    CmdSep - делим команду на несколько
    EvalCmd - выполняем одну команду


$PRIV(app) - канал связи
____________________________
SWANK: read-loop - читает сообщения из сокета.
   далее он отправляет их управляющему потоку (в почтовый ящик)


 dispatch-loop - пока не ясно, что делает, но ясно, что он достаёт сообщения из почтового ящика


 decode-message - читает сообщение из потока
   read-message - собственно читает
     read-packet - читает сначала длину сообщения, затем содержимое
     read-form - парсит сообщение


sudo rm -f /s2/tcpdump.log && sudo tcpdump -w /s2/tcpdump.log -i lo

(swank:create-server :port 4009 :dont-close t)

multithreaded-connection - здесь описаны треды


thread в сообщении swank - сначала это t
затем единица.
Разбор этого значения - в ф-ии swank::thread-for-evaluation


-- синхронное выполнение ---
Видимо, его не существует. Для него в slime ставится тред t и назначаются соответствующие продолжения.
slime-rex умеет назначать продолжения, emacs-rex из lime - не умеет.

slime-eval делает следующее:
1. Пополняет стек синхронных продолжений текущим тегом продолжения
2. Навешивает продолжение, см. ниже. 
3. Отправляет запрос.
4. Безконечно ждёт ответа
5. Продолжение смотрит, есть ли тег среди тегов синхронных продолжений
При этом обрабатываеются события :ok и :abort
5.1. Если есть, то бросает этот тег (throw)
5.2. А что же асинхронные события, к-рые в этот момент придут? видимо, они будут выполнены (slime-dispatch-event вызывается из slime-process-available-input
           Но нам не надо такого. Видимо, для этого нужно отличать синхронные от асинхроннных.


--- completion ---- 

::tkcon::Expand - completion
слово тип
ExpandProcname - добавляем ExpandLispSymbol
тогда вопрос - как добудем коннект из текст видгета?


-----------------------------------
swank::*emacs-connection* - текущее соединение с emacs. Ему шлёт сообщения ф-ия
(send-to-emacs)

Где оно связывается?

with-connection
dispatch-loop

Что делать?
а) завести вторую переменную *ltk-connection*
б) видимо, нужно всё же завести признак, является ли наше соединение внешним.



-----------------------------------------------
Есть два режима - главного интерпретатора и рабов. Мы работаем в режиме главного интерпретатора, поскольку  у нас IDE для лиспа, а не для tcl. Если мы хотим несколько листенеров, нам придётся иметь дело с режимом рабов, но я не совсем понимаю, как он работает. 

При установке swank в opt(exec) не работает .edit. 

Было бы желательно (хотя и не обязательно) восстановить возможность аттачей-детачей к разным интерпретатором. Или совсем её отрубить.

tkcon main
----------
proc tkcon - не находит не одного случая, превращает main в ::tkcon::Main и вызывает
а

proc ::tkcon::MainInit {}
  ...
  interp alias {} ::tkcon::Main {} ::tkcon::InterpEval MainMenuDup 
  

Пространство имен tkcon есть только в главном интерпретаторе.
Доступно через .tkcon main


Как хранить соединения?
-----------------------
генератор кодов использует глоб.перем в главном интерпретаторе
каждый объект соединения - это переменная с именем SwankConnection$SwankConnectionCounter,
содержит массив
очищается не знаю как - видимо, вручную?

Что содержится в соединении?
---------------------------
Сокет.
Состояние:
new - ничего
socket_only - открыт сокет
initialized - инициализирован (требуется консоль)
dead - умер
  


Именованные массивы
--------------------
а) http://wiki.tcl.tk/1032
    set name "SwankConnection234"
    variable $name
    array set $name [list a b]
    set ${name}(sock) 123123213213
    parray $name
    puts [set ${name}(sock)]
    puts "that's it"



б) Из clcon
    set name "SwankConnection333"
    variable $name
    upvar \#0 $name con
    array set $name [list a b]
    set con(sock) 123123213213
    puts $con(sock)
    puts "that's it"


Гиперссылки в тексте
------------------
Искать WriteActiveText во всех файлах *.tcl, *.l*sp 


Вставить текст в консоль:
-------------------------
.tkcon main .tab1 insert end "asdfasdf"

[::tkcon::UniqueTag .tab1]
.tkcon main {.tab1 insert end "asdfasdf" [list stderr _tag27]}
.tkcon main {.tab1 tag configure _tag27 -underline 1}

Возможно нужно делать disambiguation в списке исходников,
и указывать не на строчку, а на dspec, дающий уже уникальное место.
Тогда dspec-ы будут устойчивы к редактированию. 


В каких интерпретаторах работаем?
---------------------------------
Почти везде и раньше работаем в главном, а теперь вообще в него переключились.
Также намекает то, что в рабском нет OPT и PRIV и вообще пр-ва ::tkcon 

Зачем тогда нам нужен был не главный интерпретатор?
Проблема пока исключительно в том, что при неглавном puts пишет всегда в одну и ту же консоль.
Но мы на это забили. 

---------------------------------
Блокировать ввод на время выполнения синхронного обмена. Всё плохо:
1. grab - нужно окно.
2. busy - можно указать часть окна, но нужно переставить фокус. Фокус будет мелькать.

Таким образом, нужно программирование. Вероятно, можно сделать text с блокировкой всех событий и временно её включать на момент синхронного обмена. http://lisper.ru/forum/thread/1221/page4#comment-11321


Раскраска в ABLE:
-----------------
able::indent-current-line

able::get-current-token -> ltk::get-text-to-cursor - жрёт гигантский кусок текста от начала до текущей строчки. 

indent-current-line -> обращается к ltk:text - жрёт весь текст.


Ищем ctext.tcl
--------------
strace -xf -eopen -o out.log wish /s2/clcon/tk_samples/ctext-edit.tcl
cat out.log | grep ctext
/usr/share/tcltk/tklib0.6/ctext/ctext.tcl

Раскраску пытаемся взять из одуванчика. План работы
---------------------------------------------------

1. Как всё происходит - text только для чтения. Асинхронные сообщения. 
Событие посылается в лисп, там обрабатывается, лисп возвращает команды. 
Пометкой занимается tcl. 

2. Перекраска. Каждая команда покраски выполняется и кладётся в очередь на отправку.
Отправка происходит: 
а) при явном вызове SendDelayedColoringCommands
б) перед отправкой команды, модифицирующей текст

3. Разбираем процесс на примере одной функции:
а) нажатие буквы.
б) Indent form. 

4. Методика параллельной отладки - как сделать? Два лиспа, два емакса, в одном
clcon, в другом oduvanchik? 

Нажатие буквы: /s2/oduvanchik2/src/command.lisp
 insert-string , insert-character
 current-point - должно приходить с событием

 oduvanchik-internals::insert-character mark character

 oduvanchik-internals::mark - класс:
   line charpos %kind

 mark-некая структура, ссылающаяся на внутренние структуры odu, в т.ч. 
на line. 
 Пришёл индекс l.c -> по нему вычислить mark. Как? 
 объект line. 

 mark-line - типа
 oduvanchik-internals::line
  line-chars -> chars
  previous next
  marks
  %buffer - буфер, но может быть и ничем
  number
  
 oduvanchik-internals::buffer
   содержит 
     oduvanchik-internals::region

 buffer содержит start и end - две марки. С марков выходим на строку, со строки - на 
  следующую и т.п. Таким образом, поиск строки по номеру занимает линейное время.


ДРУГАЯ МЕТОДИКА 
---------------
Часть 1 - делаем эхо. Одуванчик рулит. На каждую операцию делаем соответствующее 
движение на стороне tcl. Тут не нужна параллельная отладка - можно делать в 
одном исходнике. 

Часть 2 - принимаем события - тоже не нужна паралл. отладка. Просто если пришло событие,
то не столь важно, откуда оно пришло. Можно ли так? Нельзя. 

Начинаем с части 2, поскольку одуванчик кривой и не может нормально обрабатывать все события: сломано undo, после нажатия insert курсор сдвигается. Поэтому лидером будет tcl. В одуванчике стараемся обойтись минимумом команд (вставка, удаление, замена). Сначала надо проверить, выражается ли в tcl undo в последовательность вызова insert,update,delete. 

Задача первого этапа - научить одуванчик зеркалить происходящее в text.

Лисповые команды одуванчика смотрим и переписываем по одной, выражая их через команды tcl. Лисп будет брать свою строку и отправлять команды в tcl. После каждой отправки команды из лиспа в tcl дожидаемся, пока состояние буфера синхронизируется от tcl. Нужно уметь блокировать виджет tcl на всё время выполнения лисповой команды. 

Также нужно понять, как работать с временными марками и точками, создаваемыми внутри команд лиспа. Видимо, их придётся выражать через марки и точки tcl edit. 



