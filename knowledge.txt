; -*- Coding: utf-8 ; mode : lisp ; -*-
(in-package :swank)


Когда набиваем, консоль сразу пытается понять, что мы набиваем. И делает она это так:
bind TkConsolePost <KeyPress>
 -> ::tkcon::TagProc
   -> EvalAttached [list info proc]
      -> EvalInSwank 


Порядок инициализации
tkcon::AtSource 
  Init 
    InputUI 
      InitMenus 
      Bindings
    OuterAttachToSwank
   
::tkcon::MainInit - вызывается только в главном интерпрететаторе, не в рабах.

порядок вызова команды
  Eval - выполняет то, что ввёл пользователь
    CmdGet
    CmdSep - делим команду на несколько
    EvalCmd - выполняем одну команду


$PRIV(app) - канал связи
____________________________
SWANK: read-loop - читает сообщения из сокета.
   далее он отправляет их управляющему потоку (в почтовый ящик)


 dispatch-loop - пока не ясно, что делает, но ясно, что он достаёт сообщения из почтового ящика


 decode-message - читает сообщение из потока
   read-message - собственно читает
     read-packet - читает сначала длину сообщения, затем содержимое
     read-form - парсит сообщение


sudo rm -f /s2/tcpdump.log && sudo tcpdump -w /s2/tcpdump.log -i lo

(swank:create-server :port 4009 :dont-close t)

multithreaded-connection - здесь описаны треды


thread в сообщении swank - сначала это t
затем единица.
Разбор этого значения - в ф-ии swank::thread-for-evaluation


-- синхронное выполнение ---
Видимо, его не существует. Для него в slime ставится тред t и назначаются соответствующие продолжения.
slime-rex умеет назначать продолжения, emacs-rex из lime - не умеет.

slime-eval делает следующее:
1. Пополняет стек синхронных продолжений текущим тегом продолжения
2. Навешивает продолжение, см. ниже. 
3. Отправляет запрос.
4. Безконечно ждёт ответа
5. Продолжение смотрит, есть ли тег среди тегов синхронных продолжений
При этом обрабатываеются события :ok и :abort
5.1. Если есть, то бросает этот тег (throw)
5.2. А что же асинхронные события, к-рые в этот момент придут? видимо, они будут выполнены (slime-dispatch-event вызывается из slime-process-available-input
           Но нам не надо такого. Видимо, для этого нужно отличать синхронные от асинхроннных.


--- completion ---- 

::tkcon::Expand - completion
слово тип
ExpandProcname - добавляем ExpandLispSymbol
тогда вопрос - как добудем коннект из текст видгета?


-----------------------------------
swank::*emacs-connection* - текущее соединение с emacs. Ему шлёт сообщения ф-ия
(send-to-emacs)

Где оно связывается?

with-connection
dispatch-loop

Что делать?
а) завести вторую переменную *ltk-connection*
б) видимо, нужно всё же завести признак, является ли наше соединение внешним.



-----------------------------------------------
Есть два режима - главного интерпретатора и рабов. Режим главного интерпретатора не подходит, т.к. некорректно работает puts при наличии более чем одной консоли.

При установке swank в opt(exec) не работает .edit. Поэтому нужно сделать отдельные поля для хранения SWANK-сокета и флаг режима SWANK, а рабский интерпретатор оставить для:
- выполнения команд .
- выполнения команды edit
- кто знает ещё для чего.



 Было бы желательно (хотя и не обязательно) восстановить возможность аттачей-детачей к разным интерпретатором. Или совсем её отрубить.


----- AS WAS ----------
Attach - подключиться к уже существующему рабу или сокет
   - подменяет EvalAttached
   - не инициализирует, а только подключается

InitSlave - создать рабский интерпретатор

NewSocket - создать сокет
  Attach

Init - инициавлизация консоли
  InitSlave
  Attach


----- AS IS ----------
OuterNewSwank -
  NewSwank (заменяем на MakeSwankConnection)

NewSwank
  set sock
  AttachSwank $sock

AttachSwank
  клон Attach
  прописывает в exec наш сокет
  SetupSwankConnection
  прописывает событие

Init - инициавлизация консоли
  InitSlave
  Attach
  OuterNewSwank

---- TO BE -----------
1.Правильно разнести newSwank и AttachSwank по функциям

можно ли вынести инициализацию в NewSwank? 
вряд ли, но можно поставить флаг, что инициализация уже
произведена и в attach инициализировать только если
ещё не инициализировано

2.У нас послойно. AttachSwank имеет рабский интерпретатор
и ещё Swank.

AttachSwank =
  Attach
  SetSwankConnection
  установить флаги, что это swank
  если ещё не инициализирован, то проинициализировать
  инициализированность относится к сокету, а не к консоли
  т.е. нужен объект соединения, к-рый содержит информацию о нём.


SetSwankConnection
  - записывает соединнеие в консоль
  - если соединение не инициализриовано, инициализирует его

tkcon main
----------
proc tkcon - не находит не одного случая, превращает main в ::tkcon::Main и вызывает
а

proc ::tkcon::MainInit {}
  ...
  interp alias {} ::tkcon::Main {} ::tkcon::InterpEval MainMenuDup 
  



Как хранить соединения?
-----------------------
генератор кодов использует глоб.перем в главном интерпретаторе
каждый объект соединения - это переменная с именем SwankConnection$SwankConnectionCounter,
содержит массив
очищается не знаю как - видимо, вручную?



Именованные массивы
--------------------
а) http://wiki.tcl.tk/1032
    set name "SwankConnection234"
    variable $name
    array set $name [list a b]
    set ${name}(sock) 123123213213
    parray $name
    puts [set ${name}(sock)]
    puts "that's it"



б) Из clcon
    set name "SwankConnection333"
    variable $name
    upvar \#0 $name con
    array set $name [list a b]
    set con(sock) 123123213213
    puts $con(sock)
    puts "that's it"
